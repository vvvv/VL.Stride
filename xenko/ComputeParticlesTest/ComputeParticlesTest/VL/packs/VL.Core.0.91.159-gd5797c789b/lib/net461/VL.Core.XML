<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VL.Core</name>
    </assembly>
    <members>
        <member name="P:VL.Core.ElementAttribute.TracingId">
            <summary>
            The element id which lead to this CLR symbol.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsImmutable">
            <summary>
            Whether or not the type is immutable.
            </summary>
        </member>
        <member name="P:VL.Core.ElementAttribute.IsManaged">
            <summary>
            Whether or not the field will be disposed when it goes out of scope during a hotswap.
            </summary>
        </member>
        <member name="T:VL.Core.EventBridge">
            <summary>
            Contains helper functions to turn .NET events into observables.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Type,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given type and event name.
            </summary>
        </member>
        <member name="M:VL.Core.EventBridge.FromEventPattern``1(System.Object,System.String)">
            <summary>
            Same as Observable.FromEventPattern but caches the resulting observable sequence for the given target object and event name.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapped">
            <summary>
            Allows objects to get notified when they've been hot swapped.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapped.Swapped(System.Object)">
            <summary>
            Called after the object has been replaced by a new instance.
            </summary>
        </member>
        <member name="T:VL.Core.INotifyHotSwapImminent">
            <summary>
            Allows objects which are currently running in the runtime graph to get notified before a hot swap takes place.
            </summary>
        </member>
        <member name="M:VL.Core.INotifyHotSwapImminent.HotSwapImminent">
            <summary>
            Called right before a hot swap will take place.
            </summary>
        </member>
        <member name="T:VL.Core.HotSwapAttribute">
            <summary>
            Forces the hot swapper to call the constructor of this type and only swap fields which also have this attribute set.
            </summary>
        </member>
        <member name="T:VL.Core.NodeContext">
            <summary>
            Contains information about the environment in which a node was created.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Default">
            <summary>
            The default context.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.Create(System.UInt32,VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new root context.
            </summary>
            <param name="rootId">The root id.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context is immutable.</param>
            <returns>The new root context.</returns>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Collections.Immutable.ImmutableStack{System.UInt32},VL.Core.IVLFactory,System.Boolean)">
            <summary>
            Creates a new context.
            </summary>
            <param name="path">The path to the node for which this context gets created.</param>
            <param name="factory">The VL factory.</param>
            <param name="isImmutable">Whether the context must be immutable.</param>
        </member>
        <member name="M:VL.Core.NodeContext.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserializes the context.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Path">
            <summary>
            The path to the node.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="F:VL.Core.NodeContext.IsImmutable">
            <summary>
            Whether or not the context is immutable. In an immutable context the state must not be modified.
            </summary>
        </member>
        <member name="M:VL.Core.NodeContext.CreateSubContext(System.UInt32)">
            <summary>
            Creates a new sub context.
            </summary>
        </member>
        <member name="T:VL.Core.ISerializer`1">
            <summary>
            The serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.ISerializer`1.Serialize(VL.Core.SerializationContext,`0)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.ISerializer`1.Deserialize(VL.Core.SerializationContext,System.Object,`0)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.SerializationContext">
            <summary>
            The serialization context.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.#ctor(VL.Core.IVLFactory,System.Boolean,System.Boolean)">
            <summary>
            Creates a new serialization context.
            </summary>
            <param name="factory">The VL factory.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
        </member>
        <member name="P:VL.Core.SerializationContext.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.ThrowOnError">
            <summary>
            Whether or not serialization error should lead to an exception
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.IncludeDefaults">
            <summary>
            Whether or not default values will also be serialized.
            </summary>
        </member>
        <member name="P:VL.Core.SerializationContext.Errors">
            <summary>
            The accumulated error messages.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationContext.ReportError(System.String)">
            <summary>
            Reports an error. Will throw a <see cref="T:VL.Core.SerializationException"/> in case <see cref="P:VL.Core.SerializationContext.ThrowOnError"/> is enabled.
            </summary>
            <param name="message">The error message to report.</param>
        </member>
        <member name="T:VL.Core.SerializationException">
            <summary>
            Represents errors that occur during serialization.
            </summary>
        </member>
        <member name="M:VL.Core.SerializationException.#ctor(System.String)">
            <summary>
            Creates a new instances of the <see cref="T:VL.Core.SerializationException"/> class with the specified error message.
            </summary>
            <param name="message">The error message.</param>
        </member>
        <member name="T:VL.Core.Serialization">
            <summary>
            Serialization related extension methods and constants.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.ReflectionNamespace">
            <summary>
            The reflection namespace.
            </summary>
        </member>
        <member name="F:VL.Core.Serialization.TypeAttributeName">
            <summary>
            The name of the type attribute.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.GetSimpleName(System.Type)">
            <summary>
            Returns the name of the type without any generic type parameter suffixes.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.GetSimpleFullName(System.Type)">
            <summary>
            Returns the full name of the type without any generic type parameter suffixes.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializer``2(VL.Core.IVLFactory,``1)">
            <summary>
            Registers a VL serializer to the factory. 
            In case the type for which the serializer gets registered is generic a dummy type instantiation paired with a dummy
            serializer instantiation containing a public default constructor has to be registered. For example a serializer implementation
            of type FooSerializer&lt;T&gt; for the generic type Foo&lt;T&gt; has to be registered for the dummy instantiaton Foo&lt;object&gt;.
            </summary>
            <typeparam name="TForType">The type for which to register a serializer.</typeparam>
            <typeparam name="TSerializer">The type of the serializer implementation.</typeparam>
            <param name="factory">The factory in which the serializer gets registered.</param>
            <param name="serializer">The serializer to register.</param>
            <returns>The factory with the registered serializer.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.SerializationContext,System.String,``0,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </typeparam>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize(VL.Core.SerializationContext,System.String,System.Object,System.Type,System.Boolean)">
            <summary>
            Serializes the given value and if a name is provided wraps the serialized content into an <see cref="T:System.Xml.Linq.XElement"/> or <see cref="T:System.Xml.Linq.XAttribute"/>. 
            </summary>
            <param name="context">The context to use for serialization.</param>
            <param name="name">The name to use (if any) for the element or attribute wrapping the serialized content.</param>
            <param name="value">The value to serialize.</param>
            <param name="staticType">
            The statically known type of the value. In case it differes from the runtime type of the value 
            the serialized content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/> with additional type information.
            </param>
            <param name="forceElement">If true the content will always be wrapped in an <see cref="T:System.Xml.Linq.XElement"/>.</param>
            <returns>The serialized content or if any wrapping happended the <see cref="T:System.Xml.Linq.XAttribute"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.SerializationContext,System.Object,System.String,``0)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize(VL.Core.SerializationContext,System.Object,System.String,System.Type,System.Object)">
            <summary>
            Deserializes the given content or if a name is provided extracts and deserializes the attribute or child element with the given name.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="name">The name of the attribute or child element to extract from the content and deserialize.</param>
            <param name="staticType">The statically known type of the value to deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.CollectionSerializer`2">
            <summary>
            The abstract base class to use when writing a VL serializer for a collection type.
            </summary>
            <typeparam name="TElement">The element type of the collection.</typeparam>
            <typeparam name="TCollection">The type of the collection.</typeparam>
        </member>
        <member name="M:VL.Core.Serialization.RegisterSerializers(VL.Core.IVLFactory)">
            <summary>
            Registers all the default serializers in the factory.
            </summary>
            <param name="factory">The factory to register in.</param>
        </member>
        <member name="M:VL.Core.Serialization.GetSerializer(VL.Core.SerializationContext,System.Type)">
            <summary>
            Gets a serializer for the given type.
            </summary>
            <param name="context">The context to fetch the serializer from.</param>
            <param name="forType">The type for which a serializer has to be fetched.</param>
            <returns>The serializer or null in case no serializer is registered for that type.</returns>
        </member>
        <member name="T:VL.Core.Serialization.Serializer">
            <summary>
            The non-generic serializer class.
            </summary>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Serialize(VL.Core.SerializationContext,System.Object)">
            <summary>
            Serializes the given value to a string, object[] or XElement.
            </summary>
            <param name="context">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized value as <see cref="T:System.String"/>, <see cref="T:Object[]"/> or <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serializer.Deserialize(VL.Core.SerializationContext,System.Object,System.Object)">
            <summary>
            Deserializes the given content.
            </summary>
            <param name="context">The context to use for deserialization.</param>
            <param name="content">The content (string, object[] or XElement) to deserialize.</param>
            <param name="defaultValue">The default value to use in case deserialization fails.</param>
            <returns>The deserialized value or the given default value in case deserialization failed.</returns>
        </member>
        <member name="T:VL.Core.Serialization.UngenericDelegatingSerializer`1">
            <summary>
            Bridge to user implemented generic serializer interface.
            </summary>
            <typeparam name="T">The type of the value to serialize.</typeparam>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case serialization fails.</remarks>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Serialize``1(VL.Core.IVLFactory,``0,System.Boolean,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Serializes the given value into an <see cref="T:System.Xml.Linq.XElement"/>. 
            </summary>
            <typeparam name="T">
            The statically known type of the value. 
            In case it differs from the runtime type a type annotation will be added to the serialized content.
            </typeparam>
            <param name="factory">The factory to use for serialization.</param>
            <param name="value">The value to serialize.</param>
            <param name="throwOnError">Whether or not serialization errors should lead to an exception.</param>
            <param name="includeDefaults">If true default values will also be serialized.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The serialized content as an <see cref="T:System.Xml.Linq.XElement"/>.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement)">
            <summary>
            Deserializes the given content.
            </summary>
            <remarks>Throws a <see cref="T:VL.Core.SerializationException"/> in case deserialization fails.</remarks>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="M:VL.Core.Serialization.Deserialize``1(VL.Core.IVLFactory,System.Xml.Linq.XElement,System.Boolean,System.Collections.Generic.IReadOnlyList{System.String}@)">
            <summary>
            Deserializes the given content.
            </summary>
            <typeparam name="T">The statically known type of the value to deserialize.</typeparam>
            <param name="factory">The factory to use for deserialization.</param>
            <param name="content">The content to deserialize.</param>
            <param name="throwOnError">Whether or not deserialization errors should lead to an exception.</param>
            <param name="errorMessages">The accumulated error messages in case <paramref name="throwOnError"/> is disabled.</param>
            <returns>The deserialized value.</returns>
        </member>
        <member name="T:VL.Core.IVLObject">
            <summary>
            Non-generic interface implemented by VL emitted classes and records.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Context">
            <summary>
            The context in which this instance was created.
            </summary>
        </member>
        <member name="P:VL.Core.IVLObject.Type">
            <summary>
            The type of the object.
            </summary>
        </member>
        <member name="T:VL.Core.IVLHub">
            <summary>
            Interface to interact with VL data hubs.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Name">
            <summary>
            The name of the data hub.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Type">
            <summary>
            The type of the data hub.
            </summary>
        </member>
        <member name="P:VL.Core.IVLHub.Value">
            <summary>
            The current value of the data hub.
            </summary>
        </member>
        <member name="T:VL.Core.IVLFactory">
            <summary>
            Interface to create VL objects.
            </summary>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeByName(System.String)">
            <summary>
            Retrieve the registered type of the given full type name.
            </summary>
            <param name="name">The full name of the type.</param>
            <returns>The type with the given full name or null.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetTypeInfo(System.Type)">
            <summary>
            Wrap the CLR type in a VL type info.
            </summary>
            <param name="type">The CLR type to wrap.</param>
            <returns>The VL type info wrapping the given CLR type.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.IsKnownType(System.Type)">
            <summary>
            Whether or not the given CLR type is known to the factory. Only type as seen by the compiler are considered to be known types.
            </summary>
            <param name="type">The type in question.</param>
            <returns>True if the type is known to the VL compiler.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.CreateInstance(System.Type,VL.Core.NodeContext)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="type">The type to create a new instance of.</param>
            <param name="nodeContext">The context to use when creating the instance.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.GetDefaultValue(System.Type)">
            <summary>
            Returns the default value of the given type as defined by VL through the CreateDefault operations.
            </summary>
            <param name="type">The type to return the default value of.</param>
            <returns>The default value of the given type as defined by VL or null if the type is not known to VL or no default has been defined.</returns>
        </member>
        <member name="M:VL.Core.IVLFactory.RegisterService(System.Type,System.Type,System.Func{System.Object,System.Object})">
            <summary>
            Registers a factory function which gets invoked when a certain service of type <paramref name="serviceType"/> is requested for
            a specific value of type <paramref name="forType"/>. The factory function must return a service of the specified <paramref name="serviceType"/>.
            </summary>
            <param name="forType">The type of the value for which a service will be requested.</param>
            <param name="serviceType">The type of the service.</param>
            <param name="serviceFactory">The factory function creating such a service.</param>
        </member>
        <member name="M:VL.Core.IVLFactory.GetServiceFactory(System.Type,System.Type)">
            <summary>
            Retrieves the factory function which will create the service of type <paramref name="serviceType"/> for the given <paramref name="forType"/>.
            </summary>
            <param name="forType">The type of the value for which a service is requested.</param>
            <param name="serviceType">The type of the service.</param>
            <returns>The factory function creating the service or null.</returns>
        </member>
        <member name="T:VL.Core.IVLTypeInfo">
            <summary>
            Interface to interact with VL types.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Factory">
            <summary>
            The VL factory.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Name">
            <summary>
            The name of the type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.ClrType">
            <summary>
            The CLR type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsPatched">
            <summary>
            Whether or not this type is a patched VL type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsClass">
            <summary>
            Whether or not this type is a VL class (mutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.IsRecord">
            <summary>
            Whether or not this type is a VL record (immutable).
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.Properties">
            <summary>
            The user defined properties of this type.
            </summary>
        </member>
        <member name="P:VL.Core.IVLTypeInfo.AllProperties">
            <summary>
            The user defined and system generated properties of this type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLTypeInfo.GetProperty(System.String)">
            <summary>
            Returns the property with the given name.
            </summary>
            <param name="name">The name of the property.</param>
            <returns>The property or null.</returns>
        </member>
        <member name="T:VL.Core.IVLPropertyInfo">
            <summary>
            Interface to interact with VL properties.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DeclaringType">
            <summary>
            The type which declared this property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Name">
            <summary>
            The name of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.Type">
            <summary>
            The type of the property.
            </summary>
        </member>
        <member name="P:VL.Core.IVLPropertyInfo.DefaultValue">
            <summary>
            The default value of the property. As of now this is just the default value of the type.
            </summary>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.GetValue(VL.Core.IVLObject)">
            <summary>
            Gets the property value of the given instance.
            </summary>
            <param name="instance">The instance to get the value from.</param>
            <returns>The value of the property.</returns>
        </member>
        <member name="M:VL.Core.IVLPropertyInfo.WithValue(VL.Core.IVLObject,System.Object)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <param name="instance">The instance to set the value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the newly set value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.GetDefaultValue``1(VL.Core.IVLFactory)">
            <summary>
            Returns the VL defined default value for the given type <typeparamref name="T"/>.
            </summary>
            <typeparam name="T">The type for which to return the VL defined default value.</typeparam>
            <param name="factory">The factory to use to create the default value.</param>
            <returns>The VL defined default value of the given type <typeparamref name="T"/>.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateInstance``1(VL.Core.IVLFactory,``0,VL.Core.NodeContext,``0@)">
            <summary>
            Tries to create an instance of the given type <typeparamref name="T"/> using the VL generated constructor.
            Returns true in case an instance was created.
            </summary>
            <typeparam name="T">The type of which to create an instance for.</typeparam>
            <param name="factory">The factory which will create the instance.</param>
            <param name="defaultValue">The default value to use in case an instance couldn't be created.</param>
            <param name="nodeContext">The context in which the new instance will be created.</param>
            <param name="instance">The newly created instance or the given default value.</param>
            <returns>True in case a new instance was created.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,System.Type,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateInstance(VL.Core.IVLFactory,VL.Core.IVLTypeInfo,System.UInt32)">
            <summary>
            Creates a new instance of the given type using the VL generated constructor.
            </summary>
            <param name="factory">The VL factory which will create the instance.</param>
            <param name="type">The type to create a new instance of.</param>
            <param name="rootId">The node id to use for the context in which the instance will be created.</param>
            <returns>The newly created instance or null if the type is not known to VL.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.RegisterService``2(VL.Core.IVLFactory,System.Func{``0,``1})">
            <summary>
            Registers a factory function which gets invoked when a service of type <typeparamref name="TService"/> is requested for
            a value of type <typeparamref name="TForType"/>.
            </summary>
            <typeparam name="TForType">The type of the value for which a service will be requested.</typeparam>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory to register the service in.</param>
            <param name="create">The factory function to invoke when such a service is requested.</param>
            <returns>The factory with the registered service.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.CreateService``1(VL.Core.IVLFactory,System.Object)">
            <summary>
            Creates a service of the given type <typeparamref name="TService"/> for the given value.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <returns>The service or null in case no service of type <typeparamref name="TService"/> was registered for the type of the value.</returns>
        </member>
        <member name="M:VL.Core.VLFactoryExtensions.TryCreateService``1(VL.Core.IVLFactory,System.Object,``0,``0@)">
            <summary>
            Tries to create a service of the given type <typeparamref name="TService"/> for the given value.
            Returns true if such a service was found for the given value, otherwise the given default service will be used.
            </summary>
            <typeparam name="TService">The type of the service.</typeparam>
            <param name="factory">The factory which creates the service.</param>
            <param name="value">The value to create the service for.</param>
            <param name="defaultService">The default service to use in case no service of that type was registered for the type of the value.</param>
            <param name="service">The registered service or the given default service.</param>
            <returns>True in case a service was found and created.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValue``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given property.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The instance to retrieve the value from.</param>
            <param name="name">The name of the property.</param>
            <param name="defaultValue">The default value to use in case retrieval failed.</param>
            <param name="value">The returned values.</param>
            <returns>True if the retrieval succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValue``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given property and returns a new instance (if it is a record) with the set value.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="instance">The instance to set the property value on.</param>
            <param name="name">The name of the property.</param>
            <param name="value">The value to set.</param>
            <returns>The new instance (if it is a record) with the set value.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.TryGetValueByPath``1(VL.Core.IVLObject,System.String,``0,``0@)">
            <summary>
            Tries to retrieve the value from the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="T">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" retrieves the first value in MySpread.</param>
            <param name="defaultValue">The default value to use in case the lookup failed.</param>
            <param name="value">The returned value.</param>
            <returns>True if the lookup succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLObjectExtensions.WithValueByPath``2(``0,System.String,``1)">
            <summary>
            Tries to set the value of the given path. The path is a dot separated string of property names.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The expected type of the value.</typeparam>
            <param name="instance">The root instance to start the lookup from.</param>
            <param name="path">A dot separated string of property names. Spreaded properties can be indexed using [N] for example "MySpread[0]" sets the first value in MySpread.</param>
            <param name="value">The value to set.</param>
            <returns>The new root instance (if it is a record) with the updated spine.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.TryGetValue``1(VL.Core.IVLPropertyInfo,VL.Core.IVLObject,``0,``0@)">
            <summary>
            Tries to get the property value of the given instance.
            </summary>
            <typeparam name="T">The expected type of the property value.</typeparam>
            <param name="property">The property to read.</param>
            <param name="instance">The instance to get the property value from.</param>
            <param name="defaultValue">The value to return in case retrieval failed.</param>
            <param name="value">The retrieved property value.</param>
            <returns>Whether or not the operation succeeded.</returns>
        </member>
        <member name="M:VL.Core.VLPropertyInfoExtensions.WithValue``2(VL.Core.IVLPropertyInfo,``0,``1)">
            <summary>
            Sets the property value of the given instance.
            </summary>
            <typeparam name="TInstance">The type of the instance.</typeparam>
            <typeparam name="TValue">The type of the value to set.</typeparam>
            <param name="property">The property to write.</param>
            <param name="instance">The instance to set the property value on.</param>
            <param name="value">The value to set.</param>
            <returns>The instance with the set value.</returns>
        </member>
        <member name="T:VL.Core.RuntimeGraph">
            <summary>
            A collection of methods used by nodes which introduce new entry points into the VL runtime graph.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Enter(VL.Core.INotifyHotSwapImminent)">
            <summary>
            Call when entering the VL runtime graph. Must be followed by a call to Exit.
            </summary>
            <param name="instance">The instance which enters the runtime graph.</param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Exit(VL.Core.INotifyHotSwapImminent)">
            <summary>
            Call when leaving the VL runtime graph. Must be preceded by a call to Enter.
            </summary>
            <param name="instance"></param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Pause(System.Int32)">
            <summary>
            Stops instances from entering the VL runtime graph. Must be followed by a call to Continue.
            </summary>
            <param name="millisecondsTimeout">The time in milli seconds to wait for instances to leave the graph.</param>
            <returns>True if no more instances are executing inside the graph.</returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.Continue">
            <summary>
            Continues execution. Must be preceded by a call to Pause.
            </summary>
        </member>
        <member name="P:VL.Core.RuntimeGraph.OnHold">
            <summary>
            Gets or sets whether or not entering in the VL runtime graph is allowed. If true Enter calls will block until set to false.
            </summary>
        </member>
        <member name="M:VL.Core.RuntimeGraph.GetRunningInstances">
            <summary>
            Gets the instances currently running inside the VL runtime graph.
            </summary>
            <returns></returns>
        </member>
        <member name="M:VL.Core.RuntimeGraph.HandleException(System.UInt32)">
            <summary>
            If an exception is set and it traces back to the given root process then it will be unset and thrown.
            </summary>
            <param name="rootId"></param>
        </member>
        <member name="M:VL.Core.RuntimeGraph.ReportException(System.Exception)">
            <summary>
            The exception to throw by the HandleAsyncException call.
            </summary>
            <param name="exception">The exception to report.</param>
        </member>
        <member name="T:VL.Core.SafeLazy`1">
            <summary>
            Provides support for lazy initialization with recursive fallback options.
            </summary>
            <typeparam name="T">The type of object that is being lazily initialized.</typeparam>
        </member>
        <member name="M:VL.Core.SafeLazy`1.GetValue(System.Func{`0},System.Func{`0})">
            <summary>
            Gets the lazily initialized value. 
            Will throw a <see cref="T:VL.Core.RecursiveCallException"/> in case the factory call is recursive and <paramref name="recursiveFallback"/> is null.
            If the <paramref name="recursiveFallback"/> is set it will be used to produce an intermediate result instead of throwing the <see cref="T:VL.Core.RecursiveCallException"/>.
            </summary>
            <param name="factory">The factory function to produce the value.</param>
            <param name="recursiveFallback">The fallback function in case the factory call is recursive. If null a <see cref="T:VL.Core.RecursiveCallException"/> will be thrown.</param>
            <returns>The lazily initialized value.</returns>
        </member>
        <member name="T:VL.Core.RecursiveCallException">
            <summary>
            This exception is thrown when the factory function of <see cref="T:VL.Core.SafeLazy`1"/> leads to a recursion.
            </summary>
        </member>
        <member name="T:VL.Core.Properties.Settings">
            <summary>
            Global HDE settings
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.NodeShowImplementationIcon">
            <summary>
            Show the icon for a nodes implementation (patch/code) even for nodes that are not in the &quot;Main&quot; namespace
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeSupport">
            <summary>
            When enabled values as well as timing information can be inspected at runtime. Has minor impact on performance however.
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowDocumentation">
            <summary>
            Display code documentation 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowLocalID">
            <summary>
            Display an items localID
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.TooltipShowOperation">
            <summary>
            Display the Operation an item is part of 
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.MouseWheelZooms">
            <summary>
            Mouse wheel zooms, + ALT pans vertically, + SHIFT pans horizontally. Otherwise mouse wheel pans vertically, + CTRL zooms
            </summary>
        </member>
        <member name="P:VL.Core.Properties.Settings.RuntimeDisableJITOptimizations">
            <summary>
            Disables JIT optimizations for dynamically emitted assemblies. Should a runtime exception occur the nodes colored red should always match the stack trace.
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareAdded">
            <summary>
            Checks for device additions, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareRemoved">
            <summary>
            Checks for device removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="P:VL.Lib.HardwareChangedEvents.HardwareChanged">
            <summary>
            Checks for device additions and removals, buffers multiple events in 2 second windows. Can fire multiple times
            </summary>
        </member>
        <member name="T:VL.Lib.GUID_DEVCLASS">
            <summary>
             Defines GUIDs for device classes used in Plug &amp; Play.
            </summary>
        </member>
        <member name="T:VL.Lib.Reactive.HoldLatestCopy`2">
            <summary>
            Holds on to a copy of the latest received data. Whenever data gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.FrameClock">
            <summary>
            The clock used to determine the time when the current frame of the vl mainloop started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentFrameTime">
            <summary>
            The time when the current frame started
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.RealTimeClock">
            <summary>
            The clock used to determine the current time, returns a new time value for each call
            </summary>
        </member>
        <member name="P:VL.Lib.Animation.Clocks.CurrentTime">
            <summary>
            Checks time now
            </summary>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTime(System.DateTime)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Animation.Time.FromDateTimeUTC(System.DateTimeOffset)">
            <summary>
            Elapsed time in seconds since midnight year 0 of the gregorian calendar
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Value">
            <summary>
            Gets the current enum value as string
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Tag">
            <summary>
            Gets the associated tag if the enum definition has registered one.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnum.CreateValue(System.String)">
            <summary>
            Creates a new enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Default">
            <summary>
            Creates the default enum value with the same type as the input instance
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnum.Definition">
            <summary>
            Gets the definition of this enum with all entries
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.OnChange">
            <summary>
            Fires when the definition changes, i.e. entries get added or removed
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.Entries">
            <summary>
            Gets the current list of valid entries
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.IDynamicEnumDefinition.IsValid(System.String)">
            <summary>
            Returns true if the string is a valid entry of this enum type
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.IDynamicEnumDefinition.EmptyEnumFallbackMessage">
            <summary>
            Gets the empty enum fallback string for cases when no entries are in the enum definition.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.IsValid(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Returns true if the value is in the current entry list of the definition.
            </summary>
            <returns>
              <c>true</c> if the specified input is valid, not null and its value is not a null or empty string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.SelectedIndex(VL.Lib.Collections.IDynamicEnum)">
            <summary>
            Gets the index of the selected item in the entries list of its definition.
            Can return -1 if the string is not in the current list of entries.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.CreateValue``1(``0,System.String)">
            <summary>
            Creates a new enum value of given type
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumExtensions.TrySelectIndex``1(``0,System.Int32,System.Boolean@,``0@)">
            <summary>
            Sets the selected item to the value at the index in the entries list of its definition.
            If the index is out of range, returns false and the input value.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumBase`2">
            <summary>
            Base class for easy dynamic enum implementaion. Use like this:
            MyEnumClass : DynamicEnumBase&lt;MyEnumClass&gt; and override 
            IDynamicEnumDefinition Definition { get; } and define a default value:
            public static MidiInputDevice Default => new MyEnumClass("Default Entry");
            <typeparam name="TSubclass">The type of the actual dynamic enum class.</typeparam>
            <typeparam name="TDefinitionClass">The type of the enum definition.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnum" />
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.DynamicEnumBase`2.CreateDefaultBase(System.String)">
            <summary>
            Can be used in subclass to create the default, selects the first entry.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.DynamicEnumDefinitionBase`1">
            <summary>
            Base class for dynamic enum definitions.
            Takes care of the singleton pattern and the update of the entries. Use like this:
            MyEnumDefinitionClass : DynamicEnumBase&lt;MyEnumDefinitionClass&gt; and override the two abstract methods.
            <typeparam name="TDefinitionSubclass">The type of the actual definition class.</typeparam>
            <seealso cref="T:VL.Lib.Collections.IDynamicEnumDefinition" />
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.ISpreadBuilder">
            <summary>
            Non-generic view on spread builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.ISpreadBuilder.ToSpread">
            <summary>
            Returns an immutable spread of the current contents of the builder.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at specified index
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at specified index
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.CopyTo(`0[],System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copies 'Count' elements from 'Start Index' to an Array at the 'Array Index' position
            </summary>
            <param name="array"></param>
            <param name="startIndex"></param>
            <param name="count"></param>
            <param name="arrayIndex"></param>
            <param name="reverseOrder"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort">
            <summary>
            Sorts the elements in the entire spread builder using the default comparer
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.SpreadBuilder`1.Sort(System.Func{`0,`0,System.Int32})">
            <summary>
            Sorts the elements in the entire spread builder using the specified comparer function
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="T:VL.Lib.Collections.ISpread">
            <summary>
            Non-generic spread interface.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.ToBuilder">
            <summary>
            Creates a spread builder with the same contents as this spread that can be efficiently modified across multiple operations
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.IsEmpty">
            <summary>
            Whether or not the spread is empty
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Count">
            <summary>
            Returns the number of slices in the spread
            </summary>
        </member>
        <member name="P:VL.Lib.Collections.Spread`1.Item(System.Int32)">
            <summary>
            Returns the item at the specified index. Can throw ArgumentOutOfRangeException exception
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.IndexOf(`0)">
            <summary>
            Searches for the specified item and returns the index of the first occurrence
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Pin">
            <summary>
            Pins the internal data array of the spread on the garbage collector to access it from unmanaged code.
            Use at your own risk, i.e. never modify bytes in it. Also make sure Unpin gets called to avoid memory leaks.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread`1.Unpin">
            <summary>
            Frees the pinned garbage collector handle, if allocated.
            </summary>
        </member>
        <member name="T:VL.Lib.Collections.Spread">
            <summary>
            Contains all those methods which are used in C# and VL.
            Methods which are only used in VL reside in SpreadNodes.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.SizeInBytes``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            The size in bytes = element type size * count.
            Returns IntPtr * count for reference types.
            </summary>
        </member>
        <member name="M:VL.Lib.Collections.Spread.GetInternalArray``1(VL.Lib.Collections.Spread{``0})">
            <summary>
            Gets the internal data array of the spread, use at your own risk, i.e. never modify it.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.HoldLatestCopy">
            <summary>
            Holds on to a copy of the latest received image. Whenever an image gets pushed to the node a copy is made and stored internally.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ArrayImage`1">
            <summary>
            Image implementation using an array as backing store.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PooledImage`1">
            <summary>
            Image implementation using a pooled array as backing store. Must be disposed.
            </summary>
            <typeparam name="T">The elment type of one channel.</typeparam>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.BitmapImage">
            <summary>
            Image implementation using a <see cref="T:System.Drawing.Bitmap"/> as backing store. Must be disposed.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IntPtrImage">
            <summary>
            Image implementation using unmanaged memory as backing store. Must be disposed.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageExtensions.Default">
            <summary>
            A white one by one pixel RGBA image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(``0[],System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String,System.Boolean)">
            <summary>
            Makes the array accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the data array gets modified later.</param>
            <returns>An image which uses the array as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage``1(VL.Lib.Collections.Spread{``0},System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the spread accessible as an image. No data gets copied.
            </summary>
            <typeparam name="T">The element type.</typeparam>
            <param name="data">The pixel data.</param>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>An image which uses the spread as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.Drawing.Bitmap,System.Boolean,System.Boolean)">
            <summary>
            Makes the bitmap accessible as an image. No data gets copied.
            </summary>
            <param name="bitmap">The bitmap to wrap.</param>
            <param name="takeOwnership">Whether or not the wrapper should take ownership of the bitmap. So in case it gets disposed the bitmap will also get disposed.</param>
            <param name="isVolatile">Whether or not the returned image is marked as volatile. Should be true in case the bitmap gets modified later.</param>
            <returns>The image wrapping the bitmap.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToImage(System.IntPtr,System.Int32,System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Makes the pointer accessible as an image. No data gets copied. The returned image is volatile and should get disposed of.
            Once disposed further access to <see cref="M:VL.Lib.Basics.Imaging.IImage.GetData"/> will return the image data from the default image.
            </summary>
            <param name="pointer">The pointer to the data of the image.</param>
            <param name="size">The size in bytes of the image data.</param>
            <param name="width">The width in pixel.</param>
            <param name="height">The height in pixel.</param>
            <param name="format">The pixel format.</param>
            <param name="originalFormat">An optional hint at the original pixel format.</param>
            <returns>A volatile image using the pointer as its backing store.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.Clone(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CloneEmpty(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Creates an empty clone of the image.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>An image of the same size and format but with all pixels set to zero.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ClonePooled(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Clones the image. The returned image uses memory from a pool and therefor must be disposed.
            </summary>
            <param name="image">The image to clone.</param>
            <returns>The cloned image. Ensure it gets disposed.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImage,VL.Lib.Basics.Imaging.ArrayImage{System.Byte}@)">
            <summary>
            Copies the source image to the destination location. If the destination is not yet assigned or if the image
            information doesn't fit a new image will be created and assigned to the destination.
            </summary>
            <param name="src">The image to copy from.</param>
            <param name="dst">The destination location to copy the image to.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.ToStream(VL.Lib.Basics.Imaging.IImage)">
            <summary>
            Makes the image accessible as a stream.
            </summary>
            <param name="image">The image to wrap.</param>
            <returns>A stream which will read from the image.</returns>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.ImageInfo,System.Byte*)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="srcInfo">The source image info.</param>
            <param name="dst">The destination pointer.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.CopyTo(VL.Lib.Basics.Imaging.IImageData,VL.Lib.Basics.Imaging.ImageInfo,System.Byte*,System.UInt32)">
            <summary>
            Copies the pixels of the image to the destination.
            </summary>
            <param name="srcData">The source image data.</param>
            <param name="srcInfo">The source image info.</param>
            <param name="dst">The destination pointer.</param>
            <param name="dstScanSize">The size in bytes of one row including padding.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageExtensions.FromImage(VL.Lib.Basics.Imaging.IImage,System.Boolean)">
            <summary>
            Makes the <see cref="T:VL.Lib.Basics.Imaging.IImage"/> accessible as a <see cref="T:System.Drawing.Bitmap"/> by either copying the pixels or wrapping them.
            </summary>
            <param name="image">The image to either copy the pixels from or wrap in a <see cref="T:System.Drawing.Bitmap"/>.</param>
            <param name="copy">Whether or not to copy the pixels.</param>
            <returns>The <see cref="T:System.Drawing.Bitmap"/> containing either the copied pixels or pointing to the upstream image data.</returns>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.ImageInfo">
            <summary>
            A structure containing size information of an image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Width">
            <summary>
            The width of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Height">
            <summary>
            The height of the image in pixel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.Format">
            <summary>
            The pixel format of the image.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.ImageInfo.OriginalFormat">
            <summary>
            The original pixel format as defined by the library the image was loaded from.
            Can be used in case the <see cref="F:VL.Lib.Basics.Imaging.ImageInfo.Format"/> property is set to <see cref="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown"/>.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.#ctor(System.Int32,System.Int32,VL.Lib.Basics.Imaging.PixelFormat,System.String)">
            <summary>
            Creates a new instance of the image info structure.
            </summary>
            <param name="width">The width of the image in pixel.</param>
            <param name="height">The height of the image in pixel.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The pixel format like it was provided by the original library.</param>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.ImageInfo.Split(System.Int32@,System.Int32@,VL.Lib.Basics.Imaging.PixelFormat@,System.String@)">
            <summary>
            Splits the image info up into its components.
            </summary>
            <param name="width">The width of the image.</param>
            <param name="height">The height of the image.</param>
            <param name="format">The pixel format of the image.</param>
            <param name="originalFormat">The original format string (if any) of the image.</param>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.PixelSize">
            <summary>
            The size of a pixel in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ImageSize">
            <summary>
            The size of the image in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.ImageInfo.ScanSize">
            <summary>
            The size of one scan line (row of pixels) in bytes.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImage">
            <summary>
            Gives read-only access to images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.Info">
            <summary>
            A structure containing size and format information of the image.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Imaging.IImage.GetData">
            <summary>
            Gives access to image's data. Must be disposed after being used.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImage.IsVolatile">
            <summary>
            A volatile image is only valid in the current call stack.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.IImageData">
            <summary>
            Used for reading images.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Pointer">
            <summary>
            The pointer to the data.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.Size">
            <summary>
            The data size in bytes.
            </summary>
        </member>
        <member name="P:VL.Lib.Basics.Imaging.IImageData.ScanSize">
            <summary>
            The scan size (one row of pixels including padding) in bytes.
            </summary>
            <remarks>If the scan size times the image height is not equal to the size data copying has to be done row by row.</remarks>
        </member>
        <member name="T:VL.Lib.Basics.Imaging.PixelFormat">
            <summary>
            An enumeration of commonly used pixel formats.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.Unknown">
            <summary>
            Unkown pixel format.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8">
            <summary>
            A single-component, 8-bit unsigned-normalized-integer format that supports 8 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R16">
            <summary>
            A single-component, 16-bit unsigned-normalized-integer format that supports 16 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32F">
            <summary>
            A single-component, 32-bit floating-point format that supports 32 bits for the red channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8">
            <summary>
            24-bit RGB pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8">
            <summary>
            24-bit BGR pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8X8">
            <summary>
            32-bit RGBx pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R8G8B8A8">
            <summary>
            32-bit RGBA pixel format using 8 bits for each channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8X8">
            <summary>
            32-bit BGRx pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.B8G8R8A8">
            <summary>
            32-bit BGRA pixel format using 8 bits for each color channel.
            </summary>
        </member>
        <member name="F:VL.Lib.Basics.Imaging.PixelFormat.R32G32B32A32F">
            <summary>
            128-bit RGBA floating point pixel format using 32 bits for each channel.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.UsingAsync``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetch a resource, use it, let it get disposed of when the Task is done.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.ToObservable``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Fetches a resource and fires a result when the worker task is done. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.InBackground``2(System.IObservable{VL.Lib.Basics.Resources.IResourceProvider{``0}},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>
            Perform an action when a new resource provider gets pushed. The action is performed on the task pool. Check the Cancelation token in your worker to stop work if cancelation was requested.
            </summary>        
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceAsyncHelpers.GetHandleAsync``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Threading.CancellationToken,System.Int32)">
            <summary>
            Retrieves the handle asnychronously.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceProvider`1">
            <summary>
            Provides an IResourceHandle, which provides access to a Disposable resource.
            Consumers need to dispose these Handles.
            Implementations provide mechanisms for distributing and sharing Disposable resources.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IResourceHandle`1">
            <summary>
            Is returned by IResourceProvider.GetHandle().
            Provides access to a Disposable Resource.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.IConnectableResourceProvider`1">
            <summary>
            A connectable resource provider only works after calling Connect. 
            Disconnect via the disposable returned by Connect(). Only then the upstream handle gets disposed of.
            Used to share Resources more efficiently while connected.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.NewPooled``2(``0,System.Func{``0,``1},System.Int32)">
            <summary>
            Manages the lifetime of a resource from a pool. Same key will return a handle to the exact same resource.
            First registered factory method wins, but will be removed on disposal of the pooled resource.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="T">Type of the resource</typeparam>
            <param name="key">The key for the pool and resource creation</param>
            <param name="factory">Factory method to create the resource from the key</param>
            <param name="delayDisposalInMilliseconds">The disposal delay in milliseconds after the last consumer has released its resource handle</param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.New``1(System.Func{``0},System.Action{``0})">
            <summary>
            Manages the lifetime of a resource.
            Every consumer will get its own handle asking the factory for a new resource.
            Disposing a handle will dispose the handle's resource.
            difference to proto: GetHandle() is not lazy, but will create the resource.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Return``1(``0)">
            <summary>
            Will always provide same single resource. It exists already. 
            So its not the responsibility of Return() to dispose it.
            
            Could also imagine a ReturnLazy that takes a Func&lt;TResource&gt;, 
            but as it is used mostly inside the monade it is already lazy to GetHandle() from downstream
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,VL.Lib.Basics.Resources.IResourceProvider{``1}})">
            <summary>
            SelectMany
            Create a ResourceProvider per source resource. Creating any provider will work.
            Takes into account that the resulting resources may depend on the source resources.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will not get managed as it may exist already. (Select(form => form.Controls[0]) should not dispose the control)
            If you create a new resource that you want to get managed use BindNew for this.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Provides a new resource for every sink, asking for a source resource every time a sink resource is demanded. No resources are shared hereby.
            The user provided resource will get managed.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Do``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Applies an action on a resource and outputs the same resource again.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Where``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,System.Boolean})">
            <summary>
            Just doesn't let you access a resource that doesn't match your needs. Gives you null instead.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Publish``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            All provided handles will now get access to the same upstream resource. 
            You may disconnect and reconnect to provide access to a new upstream resource.
            Former disposable provider Memoize
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.PublishPooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Lets you connect and disconnect manually to the source.
            Manages a pool of handles from the upstream provider.
            On GetHandle, this will return a Handle containing a resource that is not currently in use.
            Manages a pool of upstream handles. When a downstream handle gets disposed, it's inner upstream Handle will be put back into the pool.
            
            Will dispose every upstream handle still in the pool on disconnect.
            Former disposable provider Pool
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``1(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.Int32)">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After delayDisposalInMilliseconds, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.RefCount``2(VL.Lib.Basics.Resources.IConnectableResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Connects to upstream IConnectableResourceProvider when first handle is requested
            Will maintain connection until no handle is active any more
            After disposalTriggerSource fired, will disconnect from upstream IConnectableResourceProvider
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Serialize``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Handles get handed out in a serial fashion. Only one handle is in circulation at a given point in time.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32)">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify how long the resource stays valid after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareInParallel``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1})">
            <summary>
            Share a resource that may be accessed in parallel. 
            Make sure that the resource is not mutating while access is granted.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            </summary> 
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify how long the resource stays valid. 
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.ShareSerially``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share a resource that may be accessed in a serial fashion only. 
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Int32,System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify how long the resources in the pool stay valid after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.SharePooled``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.IObservable{``1},System.Action{``0})">
            <summary>
            Share resources that may be accessed in a serial fashion only.
            Manages a pool of resources, will provide either a resource from the pool or a new one if the pool is empty.
            You may specify an trigger source which signals the disposal after the RefCount goes to zero.
            Make sure you reset the resource in a way that it feels like a fresh resource.
            Note that even a delayDisposalInMilliseconds of 0 might lead to a reuse of a resource if several threads are accessing the pool.
            This is why you should always provide a valid reset method. It only gets called when a resource gets actually reused.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0})">
            <summary>
            Cata
            Empty using statement
            Only use for sideeffects of the upstream ResourceProvider Monad
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``1(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Action{``0})">
            <summary>
            Cata
            Runs the action on the resource
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Using``2(VL.Lib.Basics.Resources.IResourceProvider{``0},System.Func{``0,``1})">
            <summary>
            Cata
            Runs the extractor on the resource and returns the output.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``3(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},System.Func{``0,``1,``2})">
            <summary>
            Return a resource using two source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Return a resource using three source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.Bind``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Return a resource using four source resources.
            Does not take ownership of resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``4(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            Create a new resource using three source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="M:VL.Lib.Basics.Resources.ResourceProvider.BindNew``5(VL.Lib.Basics.Resources.IResourceProvider{``0},VL.Lib.Basics.Resources.IResourceProvider{``1},VL.Lib.Basics.Resources.IResourceProvider{``2},VL.Lib.Basics.Resources.IResourceProvider{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            Create a new resource using four source resources.
            Takes ownership of the new resource in the resulting provider.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Handle`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.Provider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation.
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.ConnectableProvider`1">
            <summary>
            Generic implementation that can be used for any on the fly implementation. 
            Helps with correct implementation of IDispoable returned by Connect().
            </summary>
        </member>
        <member name="T:VL.Lib.Basics.Resources.GetLatestResourceForTemporaryUse`1">
            <summary>
            Takes a resourceprovider and outputs its resource
            Makes sure to call GetHandle before releasing the old handle.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsFile">
            <summary>
            Returns whether the path is a file
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsDirectory">
            <summary>
            Returns whether the path is a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.IsRooted">
            <summary>
            Whether the path string contains a root.
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Root">
            <summary>
            Returns the root path (if any).
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Size">
            <summary>
            Returns the size of a file or all the files in a folder
            </summary>
        </member>
        <member name="P:VL.Lib.IO.Path.Exists">
            <summary>
            Returns whether file or folder exists
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.Refresh">
            <summary>
            Updates all properties of the path
            </summary>
            <returns></returns>
        </member>
        <member name="P:VL.Lib.IO.Path.Parent">
            <summary>
            For a directory returns its parent directory. For a file returns the directory the file is in
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDescendants(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files and folders contained withinin a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetDirectories(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all folders contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.GetFiles(System.String,System.Boolean,System.Boolean)">
            <summary>
            Returns all files contained within a directory
            </summary>
            <param name="searchPattern"></param>
            <param name="includeSubdirectories"></param>
            <param name="includeHidden"></param>
            <returns></returns>
        </member>
        <member name="M:VL.Lib.IO.Path.Filename(System.String@,System.String@,System.String@)">
            <summary>
            Returns the directory path and the name and extension of a file
            </summary>
            <param name="directory"></param>
            <param name="filename"></param>
            <param name="extension"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.GetAttributes(System.Boolean@,System.Boolean@,System.Boolean@)">
            <summary>
            Returns readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.SetAttributes(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Sets the readonly, hidden and system attributes of a file or folder
            </summary>
            <param name="isReadOnly"></param>
            <param name="isHidden"></param>
            <param name="isSystem"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.Modified(System.DateTime@,System.DateTime@,System.DateTime@)">
            <summary>
            Returns creation date, last write and last access dates of a file or folder
            </summary>
            <param name="creationTime"></param>
            <param name="lastWriteTime"></param>
            <param name="lastAccessTime"></param>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeRelative(VL.Lib.IO.Path)">
            <summary>
            Returns this absolute path as a relative path to the given base path.
            In case the base path has a different root than this path or this path is relative already 
            the same path will be returned.
            </summary>
        </member>
        <member name="M:VL.Lib.IO.Path.MakeAbsolute(VL.Lib.IO.Path)">
            <summary>
            Returns this relative path as an absolute path to the given base path.
            In case this path is absolute already the same path will be returned.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.EnumerableExtensions.Permutations``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            (a,b),(c,d) -> (a,c),(a,d),(b,c),(b,d)
            </summary>
        </member>
    </members>
</doc>
