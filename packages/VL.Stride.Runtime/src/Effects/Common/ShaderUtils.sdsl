
shader ShaderUtils
{
    // CONSTANTS ==============================================================
 
    #define TwoPi 			6.283185307179586476925286766559
    #define invTwoPi		0.15915494309189533576888376337251
    #define Pi 				3.1415926535897932384626433832795
    #define invPi 			0.31830988618379067153776752674503
    #define Epsilon         0.0000000596 // as 5.96e-08 

    // SPRITES UTILS ==============================================================
 
    void CircleSpriteDiscard(float2 uv)
    {
        if(length(uv - 0.5f) > 0.5f)
        {
            discard;
        }
    }

    static const float3 QuadPositions[4] = {
        float3(-1, 1,0),
        float3( 1, 1,0),
        float3(-1, -1,0),
        float3( 1, -1,0),
    };

    static const float2 QuadUV[4] = {
        float2(0,1), 
        float2(1,1),
        float2(0,0),
        float2(1,0)
    };

    // CULLING ==============================================================

    bool DotCulling(float3 pos, float3 eye, float3 viewDirection, float CullingThreshold)
    {
        return DotCullingDbg(pos, eye, viewDirection) > CullingThreshold;
    }

    float DotCullingDbg(float3 pos, float3 eye, float3 viewDirection)
    {
        float3 vec = pos - eye;
        float dotValue = dot(normalize(vec), viewDirection);
    
        return dotValue;
    }

    // COLOR UTILS ==============================================================

    float4 BitsToColor(float f)
    {
        uint u = asuint(f);
        float4 c;
        c = float4(
        (u>>0)%256,
        (u>>8)%256,
        (u>>16)%256,
        (u>>24)%256
        )/255.0;
        return c;
    }

    float3 HUEtoRGB(in float H)
    {
        H=frac(H);
        float R = abs(H * 6 - 3) - 1;
        float G = 2 - abs(H * 6 - 2);
        float B = 2 - abs(H * 6 - 4);
        return saturate(float3(R,G,B));
    }

    float3 HSVtoRGB(in float3 HSV)
    {
        float3 RGB = HUEtoRGB(HSV.x);
        return ((RGB - 1) * HSV.y + 1) * HSV.z;
    }

    float3 HSLtoRGB(in float3 HSL)
    {
        float3 RGB = HUEtoRGB(HSL.x);
        float C = (1 - abs(2 * HSL.z - 1)) * HSL.y;
        return (RGB - 0.5) * C + HSL.z;
    }

    float3 RGBtoHSV(in float3 RGB)
    {
        float3 HSV = 0;
        HSV.z = max(RGB.r, max(RGB.g, RGB.b));
        float M = min(RGB.r, min(RGB.g, RGB.b));
        float C = HSV.z - M;
        if (C != 0)
        {
            float4 RGB0 = float4(RGB, 0);
            float4 Delta = (HSV.z - RGB0) / C;
            Delta.rgb -= Delta.brg;
            Delta.rgb += float3(2,4,6);
            Delta.brg = step(HSV.z, RGB) * Delta.brg;
            HSV.x = max(Delta.r, max(Delta.g, Delta.b));
            HSV.x = frac(HSV.x / 6);
            HSV.y = 1 / Delta.w;
        }
        return HSV;
    }

    /* previous RGBtoHSL */
    //float3 RGBtoHSL(in float3 RGB)
    //{
    //    float3 HSL = 0;
    //    float U, V;
    //    U = -min(RGB.r, min(RGB.g, RGB.b));
    //    V = max(RGB.r, max(RGB.g, RGB.b));
    //    HSL.z = (V - U) * 0.5;
    //    float C = V + U;
    //    if (C != 0)
    //    {
    //        float3 Delta = (V - RGB) / C;
    //        Delta.rgb -= Delta.brg;
    //        Delta.rgb += float3(2,4,6);
    //        Delta.brg = step(V, RGB) * Delta.brg;
    //        HSL.x = max(Delta.r, max(Delta.g, Delta.b));
    //        HSL.x = frac(HSL.x / 6);
    //        HSL.y = C / (1 - abs(2 * HSL.z - 1));
    //    }
    //    return HSL;
    //}

    float3 RGBtoHCV(in float3 RGB)
      {
        // RGB - HSL - HSV conversions as by https://www.chilliant.com/rgb2hsv.html
        // Based on work by Sam Hocevar and Emil Persson
        float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0/3.0) : float4(RGB.gb, 0.0, -1.0/3.0);
        float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
        float C = Q.x - min(Q.w, Q.y);
        float H = abs((Q.w - Q.y) / (6 * C + Epsilon) + Q.z);
        return float3(H, C, Q.x);
    }

    float3 RGBtoHSL(in float3 RGB)
    {
        float3 HCV = RGBtoHCV(RGB);
        float L = HCV.z - HCV.y * 0.5;
        float S = HCV.y / (1 - abs(L * 2 - 1) + Epsilon);
        return float3(HCV.x, S, L);
    }

    // VALUE UTILS ==============================================================
    
    float ScaleOffsetScale(float x, float3 sos)
    {
        return ((x * sos.x) + sos.y) * sos.z;
    }

    // ROTATION ==============================================================

    float2 r2d(float2 pt, float2 o, float a)
    {
        float x = cos(a) * (pt.x - o.x) + sin(a) * (pt.y - o.y) + o.x;
        float y = cos(a) * (pt.y - o.y) - sin(a) * (pt.x - o.x) + o.y;
        return float2(x,y);
    }

    float2 r2d(float2 pt, float a)
    {
        float x = cos(a) * pt.x + sin(a) * pt.y;
        float y = cos(a) * pt.y - sin(a) * pt.x;
        return float2(x,y);
    }
};