#ifndef InputControlPointCount
# define InputControlPointCount 4
#endif

#ifndef OutputControlPointCount
# define OutputControlPointCount 4
#endif


shader BSpline_Tessellation_ShaderFX :   ShaderBase, TransformationBase, PositionStream4, BSplineStream, Transformation, NormalBase, ShaderUtils
{
    patchstream float tessFactor[4]         : SV_TessFactor;
    patchstream float insideTessFactor[2]   : SV_InsideTessFactor;

    cbuffer PerMaterial
	{
		stage int  Length = 16;      
        stage int  Width = 8;
        stage int  Cap = 6;
        stage bool Ribbon;
        stage float GlobalWidth = 1;
	}


    override stage void VSMain()
    {
        // streams to Domain need to fill here
        streams.TessLength = Length;
        streams.TessWidth  = Width;
        streams.TessCap    = Cap;
        streams.TessRibbon = Ribbon;
        streams.TubeWidth  = GlobalWidth;

        base.VSMain();
    }

    [domain("quad")]
    [partitioning("integer")]
    [outputtopology("triangle_cw")]
    [outputcontrolpoints(OutputControlPointCount)]
    [patchconstantfunc("HSConstantMain")]
    void HSMain(InputPatch<Input, InputControlPointCount> input, out Output output, uint uCPID : SV_OutputControlPointID) 
    {
        const uint NextCPID = uCPID < 2 ? uCPID + 1 : 0;

        streams = input[uCPID];

        
        
        output = streams;
    }

    void HSConstantMain(InputPatch<Input, InputControlPointCount> input, const OutputPatch<Input2, OutputControlPointCount> output, out Constants constants) 
    {
        float len   =   output[0].TessCap * output[0].FrontCap + 
                        min(64-(2*output[0].TessCap),max(2,output[0].TessLength)) + 
                        output[0].TessCap * output[0].EndCap;

        float width = max(1,output[0].TessWidth );
        constants.tessFactor[0] = len;
        constants.tessFactor[1] = width;
        constants.tessFactor[2] = len;
        constants.tessFactor[3] = width;
        constants.insideTessFactor[0] = width;
        constants.insideTessFactor[1] = len;
    }
    
    [domain("quad")]
    void DSMain(const OutputPatch<Input, OutputControlPointCount> input, out Output output, in Constants constants, float2 uv : SV_DomainLocation) 
    {    
        float leng = min(64-(2*input[0].TessCap),max(2,input[0].TessLength));
        float shift = input[0].TessCap/leng;
        float y = (uv.y * ((input[0].TessCap*input[0].FrontCap + leng + input[0].TessCap*input[0].EndCap)/ leng)) -  shift * input[0].FrontCap;

        float t = clamp(y,0,1);
		float angle = (uv.x*2-.5) * Pi;
        float capangle = ((y < 0)*y/shift + (y > 1)*(y-1)/shift) * Pi *.5 ;

		float omt = 1.0f-t;
		float omt2 = omt * omt;
		float t2 = t * t;
		
		float m0 = omt2 * omt;
		float m1 = 3.0f * omt2 * t;
		float m2 = 3.0f * omt * t2;
		float m3 = t2 * t;

        float3 position =	input[0].Pos0 * m0 + input[0].Pos1 * m1 + input[0].Pos2 * m2 + input[0].Pos3 * m3;
		float3 tangent	=	normalize(
							input[0].Pos0 * ( -omt2 ) +
							input[0].Pos1 * (  3.0f * omt2 - 2.0f * omt ) +
							input[0].Pos2 * ( -3.0f * t2   + 2.0f * t ) +
							input[0].Pos3 * ( t2 )
							);
        float4 view     =    mul(float4(0,0,-1,1), ViewInverse);
		float3 up		= 	normalize( input[0].Up0 * m0 + input[0].Up1 * m1 + input[0].Up2 * m2 + input[0].Up3 * m3) * (input[0].TessRibbon == 0) + view * view.w *(input[0].TessRibbon != 0) ;
		float3 binormal	=	normalize(cross( up, tangent ));
		float3 normal	=	normalize(cross( tangent, binormal ));
		float2 wh 		=	input[0].WH0 * m0 + input[0].WH1 * m1 + input[0].WH2 * m2 + input[0].WH3 * m3;
		float3 circle   =   input[0].TubeWidth * (
                                (normal*wh.y*cos(angle) + normalize(cross(normal,tangent))*wh.x*sin(angle)) * cos(capangle) +
                                tangent*max(wh.x,wh.y)*sin(capangle)
                            );


        streams.normalWS   = normalize(circle);
        streams.PositionWS = mul(float4(position + circle,1) , World);

        this.BaseTransformDS();

        output = streams;
    }

    stage override void BaseTransformVS()
    {
        this.PreTransformPosition();
    }

    stage void BaseTransformDS()
    {
        this.TransformPosition();
        this.PostTransformPosition();
    }
    
    stage override void TransformPosition()
    {
        base.TransformPosition();

        // Apply tessellation map, etc...
        TessellateDomain();
    }

    stage void TessellateDomain() {}

};